/*********************************************************************
 * Common set of tools (classes & functions)
 *
 * Endianness-aware integer classes/types
 *
 * Copyright (C) 2003 Julien Coloos.  All rights reserved.
 *
 * This file may be distributed under the terms of the Q Public License
 * as defined by Trolltech AS of Norway and appearing in the file
 * LICENSE.QPL included in the packaging of this file.
 *
 * This file may be distributed and/or modified under the terms of the
 * GNU General Public License version 2 as published by the Free Software
 * Foundation and appearing in the file LICENSE.GPL included in the
 * packaging of this file.
 *
 * Licensees holding an other license may use this file in accordance with 
 * the Agreement provided with the Software.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * See http://www.opensource.org/licenses/qtpl.php for QPL licensing information.
 * See http://www.opensource.org/licenses/gpl-license.html for GPL licensing information.
 *
 * Contact cyrius@corecodec.org if any conditions of this licensing
 * are not clear to you.
 *
 ********************************************************************/

#ifndef __TOOLS_COMMON_ENDIAN_H__
#define __TOOLS_COMMON_ENDIAN_H__

#include "common.h"
// This file should have been generated by a small tool and give information
// on endianness
#include "common_endian_generated.h"


typedef enum {
	kBigEndian,
	kLittleEndian
} eEndianness;


#if BYTE_ORDER == LIL_ENDIAN
#	define SYSTEM_ENDIAN	kLittleEndian
#elif BYTE_ORDER == BIG_ENDIAN
#	define SYSTEM_ENDIAN	kBigEndian
#endif


#if defined(USE_ENDIAN_CLASSES)

template<class _T, eEndianness _ENDIANNESS>
class TOOLS_DLL_API EndianValue {
protected:
	_T	m_Value;

public:
	// Defining ctors cause troubles in unions
	//EndianValue<_T, _ENDIANNESS>(void) { };
	//EndianValue<_T, _ENDIANNESS>(const _T& value) {
	//	*this = value;
	//};
	inline operator _T(void) const {
#if BYTE_ORDER == LIL_ENDIAN
		if(_ENDIANNESS == kLittleEndian)
			return m_Value;
		else {
			_T value = m_Value;
			std::reverse(reinterpret_cast<uint8 *>(&value), reinterpret_cast<uint8 *>((&value)+1));
			return value;
		}
#else
		if(_ENDIANNESS == kBigEndian)
			return m_Value;
		else {
			_T value = m_Value;
			std::reverse(reinterpret_cast<uint8 *>(&value), reinterpret_cast<uint8 *>((&value)+1));
			return value;
		}
#endif
	};
	inline EndianValue<_T, _ENDIANNESS>& operator =(const _T& value) {
		m_Value = value;
#if BYTE_ORDER == LIL_ENDIAN
		if(_ENDIANNESS == kBigEndian)
			std::reverse(reinterpret_cast<uint8 *>(&m_Value), reinterpret_cast<uint8 *>((&m_Value)+1));
#else
		if(_ENDIANNESS == kLittleEndian)
			std::reverse(reinterpret_cast<uint8 *>(&m_Value), reinterpret_cast<uint8 *>((&m_Value)+1));
#endif
		return *this;
	};
	// If this is defined, we get an error C2622 because union members can't have
	// an assignment operator
	//inline EndianValue<_T, _ENDIANNESS>& operator =(const EndianValue<_T, _ENDIANNESS>& value) {
	//	m_Value = value.m_Value;
	//	return *this;
	//};
	// The 'conventional' binary operators mustn't be defined (at least
	// with MSVC) because a proper conversion is already done by the
	// compiler (overloading again the operator generates problems)
#define DEFINE_ENDIANVALUE_BINARY_OPERATOR_1(op)						\
	inline EndianValue<_T, _ENDIANNESS>& operator op(const _T& value) {	\
		*this = _T(*this) op value;										\
		return *this;													\
	};
#define DEFINE_ENDIANVALUE_BINARY_OPERATOR_2(op)							\
	inline EndianValue<_T, _ENDIANNESS>& operator op##=(const _T& value) {	\
		*this = _T(*this) op value;											\
		return *this;														\
	};
#define DEFINE_ENDIANVALUE_COMPARISON_OPERATOR(op)								\
	inline bool operator op(const EndianValue<_T, _ENDIANNESS>& value) const {	\
		return (m_Value op value.m_Value);										\
	};
#define DEFINE_ENDIANVALUE_BINARY_OPERATOR(op)						\
DEFINE_ENDIANVALUE_BINARY_OPERATOR_2(op)
	DEFINE_ENDIANVALUE_BINARY_OPERATOR(+)
	DEFINE_ENDIANVALUE_BINARY_OPERATOR(-)
	DEFINE_ENDIANVALUE_BINARY_OPERATOR(*)
	DEFINE_ENDIANVALUE_BINARY_OPERATOR(/)
	DEFINE_ENDIANVALUE_BINARY_OPERATOR(%)
	DEFINE_ENDIANVALUE_BINARY_OPERATOR(&)
	DEFINE_ENDIANVALUE_BINARY_OPERATOR(|)
	DEFINE_ENDIANVALUE_BINARY_OPERATOR(<<)
	DEFINE_ENDIANVALUE_BINARY_OPERATOR(>>)
	DEFINE_ENDIANVALUE_COMPARISON_OPERATOR(==)
	DEFINE_ENDIANVALUE_COMPARISON_OPERATOR(!=)
	DEFINE_ENDIANVALUE_COMPARISON_OPERATOR(<)
	DEFINE_ENDIANVALUE_COMPARISON_OPERATOR(<=)
	DEFINE_ENDIANVALUE_COMPARISON_OPERATOR(>)
	DEFINE_ENDIANVALUE_COMPARISON_OPERATOR(>=)
	inline EndianValue<_T, _ENDIANNESS>& operator ++(void) {
		*this = _T(*this) + 1;
		return *this;
	};
	inline _T operator ++(int) {
		_T value = _T(*this);
		++*this;
		return value;
	};
	inline EndianValue<_T, _ENDIANNESS>& operator --(void) {
		*this = _T(*this) - 1;
		return *this;
	};
	inline _T operator --(int) {
		_T value = _T(*this);
		--*this;
		return value;
	};
};


// Instantiate some EndianValue<...> classes
// This does not create an object. It only forces the generation of all of the members
// of the class. It exports them from the DLL and imports them into the .exe file.
TOOLS_EXPIMP_TEMPLATE template class TOOLS_DLL_API EndianValue<uint16, kLittleEndian>;
TOOLS_EXPIMP_TEMPLATE template class TOOLS_DLL_API EndianValue<uint32, kLittleEndian>;
TOOLS_EXPIMP_TEMPLATE template class TOOLS_DLL_API EndianValue<uint64, kLittleEndian>;
TOOLS_EXPIMP_TEMPLATE template class TOOLS_DLL_API EndianValue<sint16, kLittleEndian>;
TOOLS_EXPIMP_TEMPLATE template class TOOLS_DLL_API EndianValue<sint32, kLittleEndian>;
TOOLS_EXPIMP_TEMPLATE template class TOOLS_DLL_API EndianValue<sint64, kLittleEndian>;
TOOLS_EXPIMP_TEMPLATE template class TOOLS_DLL_API EndianValue<uint16, kBigEndian>;
TOOLS_EXPIMP_TEMPLATE template class TOOLS_DLL_API EndianValue<uint32, kBigEndian>;
TOOLS_EXPIMP_TEMPLATE template class TOOLS_DLL_API EndianValue<uint64, kBigEndian>;
TOOLS_EXPIMP_TEMPLATE template class TOOLS_DLL_API EndianValue<sint16, kBigEndian>;
TOOLS_EXPIMP_TEMPLATE template class TOOLS_DLL_API EndianValue<sint32, kBigEndian>;
TOOLS_EXPIMP_TEMPLATE template class TOOLS_DLL_API EndianValue<sint64, kBigEndian>;

#if BYTE_ORDER == BIG_ENDIAN
typedef EndianValue<uint16, kLittleEndian>	uint16_le;
typedef EndianValue<uint32, kLittleEndian>	uint32_le;
typedef EndianValue<uint64, kLittleEndian>	uint64_le;
typedef EndianValue<sint16, kLittleEndian>	sint16_le;
typedef EndianValue<sint32, kLittleEndian>	sint32_le;
typedef EndianValue<sint64, kLittleEndian>	sint64_le;
typedef uint16	uint16_be;
typedef uint32	uint32_be;
typedef uint64	uint64_be;
typedef sint16	sint16_be;
typedef sint32	sint32_be;
typedef sint64	sint64_be;
#elif BYTE_ORDER == LIL_ENDIAN
typedef uint16	uint16_le;
typedef uint32	uint32_le;
typedef uint64	uint64_le;
typedef sint16	sint16_le;
typedef sint32	sint32_le;
typedef sint64	sint64_le;
typedef EndianValue<uint16, kBigEndian>		uint16_be;
typedef EndianValue<uint32, kBigEndian>		uint32_be;
typedef EndianValue<uint64, kBigEndian>		uint64_be;
typedef EndianValue<sint16, kBigEndian>		sint16_be;
typedef EndianValue<sint32, kBigEndian>		sint32_be;
typedef EndianValue<sint64, kBigEndian>		sint64_be;
#endif

#endif /* USE_ENDIAN_CLASSES */


#define _SWAP_16(x)							\
	((((x)&0xFF00)>>8) | (((x)&0x00FF)<<8))

#define _SWAP_32(x)										\
	((((x)&0xFF000000)>>24) | (((x)&0x00FF0000)>>8)		\
	| (((x)&0x0000FF00)<<8) | (((x)&0x000000FF)<<24))

#define _SWAP_64(x)							\
	((((x)&_LL(0xFF00000000000000))>>56)	\
	| (((x)&_LL(0x00FF000000000000))>>40)	\
	| (((x)&_LL(0x0000FF0000000000))>>24)	\
	| (((x)&_LL(0x000000FF00000000))>>8)	\
	| (((x)&_LL(0x00000000FF000000))<<8)	\
	| (((x)&_LL(0x0000000000FF0000))<<24)	\
	| (((x)&_LL(0x000000000000FF00))<<40)	\
	| (((x)&_LL(0x00000000000000FF))<<56))

#define FIX_ENDIAN(x,bits,aim,endian)		\
	x = INT##bits##_##aim##_##endian(x);

#if BYTE_ORDER == BIG_ENDIAN

#define INT16_FROM_BE(x)	(x)
#define INT32_FROM_BE(x)	(x)
#define INT64_FROM_BE(x)	(x)
#define INT16_TO_BE(x)		(x)
#define INT32_TO_BE(x)		(x)
#define INT64_TO_BE(x)		(x)
#define INT16_FROM_LE(x)	_SWAP_16(x)
#define INT32_FROM_LE(x)	_SWAP_32(x)
#define INT64_FROM_LE(x)	_SWAP_64(x)
#define INT16_TO_LE(x)		_SWAP_16(x)
#define INT32_TO_LE(x)		_SWAP_32(x)
#define INT64_TO_LE(x)		_SWAP_64(x)
#define FIX_INT16_FROM_BE(x)
#define FIX_INT32_FROM_BE(x)
#define FIX_INT64_FROM_BE(x)
#define FIX_INT16_TO_BE(x)
#define FIX_INT32_TO_BE(x)
#define FIX_INT64_TO_BE(x)
#define FIX_INT16_FROM_LE(x)	FIX_ENDIAN(x,16,FROM,LE)
#define FIX_INT32_FROM_LE(x)	FIX_ENDIAN(x,32,FROM,LE)
#define FIX_INT64_FROM_LE(x)	FIX_ENDIAN(x,64,FROM,LE)
#define FIX_INT16_TO_LE(x)		FIX_ENDIAN(x,16,TO,LE)
#define FIX_INT32_TO_LE(x)		FIX_ENDIAN(x,32,TO,LE)
#define FIX_INT64_TO_LE(x)		FIX_ENDIAN(x,64,TO,LE)

#elif BYTE_ORDER == LIL_ENDIAN

#define INT16_FROM_BE(x)	_SWAP_16(x)
#define INT32_FROM_BE(x)	_SWAP_32(x)
#define INT64_FROM_BE(x)	_SWAP_64(x)
#define INT16_TO_BE(x)		_SWAP_16(x)
#define INT32_TO_BE(x)		_SWAP_32(x)
#define INT64_TO_BE(x)		_SWAP_64(x)
#define INT16_FROM_LE(x)	(x)
#define INT32_FROM_LE(x)	(x)
#define INT64_FROM_LE(x)	(x)
#define INT16_TO_LE(x)		(x)
#define INT32_TO_LE(x)		(x)
#define INT64_TO_LE(x)		(x)
#define FIX_INT16_FROM_BE(x)	FIX_ENDIAN(x,16,FROM,BE)
#define FIX_INT32_FROM_BE(x)	FIX_ENDIAN(x,32,FROM,BE)
#define FIX_INT64_FROM_BE(x)	FIX_ENDIAN(x,64,FROM,BE)
#define FIX_INT16_TO_BE(x)		FIX_ENDIAN(x,16,TO,BE)
#define FIX_INT32_TO_BE(x)		FIX_ENDIAN(x,32,TO,BE)
#define FIX_INT64_TO_BE(x)		FIX_ENDIAN(x,64,TO,BE)
#define FIX_INT16_FROM_LE(x)
#define FIX_INT32_FROM_LE(x)
#define FIX_INT64_FROM_LE(x)
#define FIX_INT16_TO_LE(x)
#define FIX_INT32_TO_LE(x)
#define FIX_INT64_TO_LE(x)

#endif


#endif // __TOOLS_COMMON_ENDIAN_H__
